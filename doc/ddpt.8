.TH DDPT "8" "June 2010" "ddpt\-0.91" DDPT
.SH NAME
ddpt \- copies data between files and storage devices. Support for
devices that understand the SCSI command set.
.SH SYNOPSIS
.B ddpt
[\fIbs=BS\fR] [\fIconv=CONVS\fR] [\fIcount=COUNT\fR] [\fIibs=IBS\fR]
\fIif=IFILE\fR [\fIiflag=FLAGS\fR] [\fIobs=OBS\fR] [\fIof=OFILE\fR]
[\fIoflag=FLAGS\fR] [\fIseek=SEEK\fR] [\fIskip=SKIP\fR] [\fIstatus=STAT\fR]
[\fI\-\-help\fR] [\fI\-\-version\fR]
.PP
[\fIbpt=BPT[,OBPC]\fR] [\fIcdbsz=\fR6|10|12|16] [\fIcoe=\fR0|1]
[\fIcoe_limit=CL\fR] [\fIof2=OFILE2\fR] [\fIretries=RETR\fR]
[\fIverbose=VERB\fR] [\fI\-\-verbose\fR]
.SH DESCRIPTION
.\" Add any additional description here
.PP
Copy data to and from any files. Specialized for "files" that are
SCSI (or SCSI like) direct access storage devices (e.g. SATA and SAS disks,
plus DVD drives). Can issue SCSI commands in pass\-through ("pt") mode.
Similar syntax and semantics to the Unix
.B dd(1)
command.
.PP
The first grouping in the synopsis above lists recent GNU
.B dd(1)
options. The second grouping contains extra options added by this utility.
Both groupings are merged below and defined in alphabetical order.
See the section on DD DIFFERENCES for more information.
.PP
The term "pt device" is used for a pass\-through device to which SCSI
commands like READ(10) and WRITE(10) may be sent. A pt device may only be
able to process SCSI commands in which case the "pt" flag is assumed. The
ability to recognize such a pt only device may vary depending on the
operating system (e.g. in Linux '/dev/sg2' is recognized). However
if a device can process either normal UNIX read()/write() calls or
pass\-through SCSI commands then the default is to use UNIX read()/write()
calls. That default can be overridden by using the "pt"
flag (e.g. "if=/dev/sdc iflag=pt").
.SH OPTIONS
.TP
\fBbpt\fR=\fIBPT[,OBPC]\fR
where \fIBPT\fR is Blocks Per Transfer optionally followed by \fIOBPC\fR
which is Output Blocks Per Check. The copy is made up of multiple
transfers, each first reading \fIBPT\fR input blocks (i.e. \fIBPT*IBS\fR
bytes) and then writing \fIBPT*IBS/OBS\fR output blocks. This continues
until the copy is finished, with the last transfer being potentially smaller.
The default \fIBPT\fR value is 128 for block sizes less that 2048 bytes,
otherwise the default is 32. If \fIBPT\fR is given as 0 it is treated as
the default value.  So for "bs=512" the reads will each convey 64 KiB of
data by default (less if near the end of the transfer or memory
restrictions). For example the media in cd/dvd drives has a block size of
2048 bytes so bpt defaults to 32 which again implies 64 KiB transfers.
The default granularity for sparse writes and write sparing checks (i.e.
comparisons) is \fIBPT*IBS\fR bytes. That can be reduced by giving
\fIOBPC\fR with the finest granularity being when \fIOBPC\fR is 1 which
implies the unit of comparisons is \fIOBS\fR bytes. When \fIOBPC\fR is 0
or not given the default granularity is used. 
.TP
\fBbs\fR=\fIBS\fR
where \fIBS\fR is the \fIIFILE\fR and \fIOFILE\fR block size in bytes.
Cannot be used with either "ibs=" or "obs=" options. The value of \fIBS\fR
is placed in \fIIBS\fR and \fIOBS\fR.
If \fIIFILE\fR or \fIOFILE\fR is a "pt" device then \fIBS\fR
.B must
be the logical block size of the physical input device.
Note that this differs from
.B dd(1)
which permits \fIBS\fR to be an integral multiple. Default is 512 which
is usually correct for disks but incorrect for dvds (which normally
have 2048 byte blocks).
.TP
\fBcdbsz\fR=6 | 10 | 12 | 16
size of SCSI READ and/or WRITE commands issued on pt devices.
Default is 10 byte SCSI command blocks (unless calculations indicate
that a 4 byte block number may be exceeded or \fIBPT\fR is greater than
16 bits (65535), in which case it defaults to 16 byte SCSI commands).
.TP
\fBcoe\fR=0 | 1
set to 1 for continue on error. Only applies to errors on pt
devices. Thus errors on other files will stop ddpt. Default is 0 which
implies stop on any error. See the 'coe' flag for more information.
.TP
\fBcoe_limit\fR=\fICL\fR
where \fICL\fR is the maximum number of consecutive bad blocks stepped
over (due to "coe=1") on reads before the copy terminates. This only
applies when \fIIFILE\fR is a pt device. The default is 0 which is
interpreted as no limit. This option is meant to stop the copy soon after
unrecorded media is detected while still offering "continue on error"
capability.
.TP
\fBconv\fR=\fICONVS\fR
see the CONVERSIONS section below.
.TP
\fBcount\fR=\fICOUNT\fR
copy \fICOUNT\fR input blocks from \fIIFILE\fR to \fIOFILE\fR. If this
option is not given (or \fICOUNT\fR is '\-1') then the \fICOUNT\fR may be
deduced from either \fIIFILE\fR or \fIOFILE\fR. See the COUNT section below.
.TP
\fBibs\fR=\fIIBS\fR
where \fIIBS\fR is the \fIIFILE\fR block size in bytes. The default value
of \fIIBS\fR is 512. Cannot be used together with the "bs=" option.
.TP
\fBif\fR=\fIIFILE\fR
read from \fIIFILE\fR. This option must be given (i.e. it is mandatory). If
\fIIFILE\fR is '\-' then stdin is read. Starts reading at the beginning of
\fIIFILE\fR unless \fISKIP\fR is given.
.TP
\fBiflag\fR=\fIFLAGS\fR
where \fIFLAGS\fR is a comma separated list of one or more flags outlined
below.  These flags are associated with \fIIFILE\fR and are ignored when
\fIIFILE\fR is stdin.
.TP
\fBobs\fR=\fIOBS\fR
where \fIOBS\fR is the \fIOFILE\fR block size in bytes. The default value 
of \fIOBS\fR is 512.
If \fIOBS\fR is given then is has the following restriction:
the integer expression (((\fIIBS\fR * \fIBPT\fR) % \fIOBS\fR) == 0) must
be true. Stated another way: the input buffer size must be an integral
multiple of \fIOBS\fR. If \fIof2=OFILE2\fR is given then \fIOBS\fR is
its block size as well.
.TP
\fBof\fR=\fIOFILE\fR
write to \fIOFILE\fR. The default value is /dev/null . If \fIOFILE\fR is '\-'
then writes to stdout. If \fIOFILE\fR is /dev/null then no actual writes are
performed. If \fIOFILE\fR is '.' (period) then it is treated the same way as
/dev/null (this is a shorthand notation). If \fIOFILE\fR exists then it
is _not_ truncated; it is overwritten from the start of \fIOFILE\fR
unless 'oflag=append' or \fISEEK\fR is given.
.TP
\fBof2\fR=\fIOFILE2\fR
write output to \fIOFILE2\fR. The default action is not to do this additional
write (i.e. when this option is not given). \fIOFILE2\fR is assumed to be
a regular file or a fifo (i.e. a named pipe). \fIOFILE2\fR is opened for
writing and is created if necessary. If \fIOFILE2\fR is a fifo (named pipe)
then some other command should be consuming that data (e.g. 'md5sum OFILE2'),
otherwise this utility will block. The write to \fIOFILE2\fR occurs before
the write to \fIOFILE\fR and prior to sparse writing and write sparing
logic. So everything read is written to \fIOFILE2\fR.
.TP
\fBoflag\fR=\fIFLAGS\fR
where \fIFLAGS\fR is a comma separated list of one or more flags outlined
below.  These flags are associated with \fIOFILE\fR and are ignored when
\fIOFILE\fR is /dev/null, '.' (period), or stdout.
.TP
\fBretries\fR=\fIRETR\fR
sometimes retries at the host are useful, for example when there is a
transport error. When \fIRETR\fR is greater than zero then SCSI READs and
WRITEs are retried on error, \fIRETR\fR times. Default value is zero.
.TP
\fBseek\fR=\fISEEK\fR
start writing \fISEEK\fR \fIOBS\fR\-sized blocks from the start of
\fIOFILE\fR. Default is block 0 (i.e. start of file). The \fISEEK\fR value
may exceed the number of \fIOBS\fR\-sized blocks in \fIOFILE\fR.
.TP
\fBskip\fR=\fISKIP\fR
start reading \fISKIP\fR \fIIBS\fR\-sized blocks from the start of
\fIIFILE\fR. Default is block 0 (i.e. start of file). The \fISKIP\fR value
must be less than the number of \fIIBS\fR\-sized blocks in \fIIFILE\fR.
.TP
\fBstatus\fR=\fISTAT\fR
the \fISTAT\fR value of 'noxfer' suppresses the throughput calculation and
the elapsed time output. As a convenience the value 'null' is accepted and
does nothing. The default action is to show the throughput calculation and
the elapsed time output and the end of the copy.
.TP
\fBverbose\fR=\fIVERB\fR
as \fIVERB\fR increases so does the amount of debug output sent to stderr.
Default value is zero which yields the minimum amount of debug output.
A value of 1 reports extra information that is not repetitive. A value
2 reports cdbs and responses for SCSI commands that are not repetitive
(i.e. other that READ and WRITE). Error processing is not considered
repetitive. Values of 3 and 4 yield output for all SCSI commands, plus
Unix read() and write() calls, so there can be a lot of output.
.TP
\fB\-h\fR, \fB\-\-help\fR
outputs usage message and exits.
.TP
\fB\-v\fR, \fB\-\-verbose\fR
equivalent of \fIverbose=1\fR. If \fI\-\-verbose\fR appears twice then
that is equivalent to \fIverbose=2\fR. Also \fI\-vv\fR is equivalent to
\fIverbose=2\fR.
.TP
\fB\-V\fR, \fB\-\-version\fR
outputs version number information and exits.
.SH COUNT
When the \fIcount=COUNT\fR option is not given (or \fICOUNT\fR is '\-1')
then an attempt is made to deduce \fICOUNT\fR as follows.
.PP
When both or either \fIIFILE\fR and \fIOFILE\fR are block devices, then
the minimum size, expressed in units of input blocks, is used. When both or
either \fIIFILE\fR and \fIOFILE\fR are pass\-through devices, then the
minimum size, expressed in units of input blocks, is used.
.PP
If a regular file is used as input, its size, expressed in units of input
blocks (and rounded up if necessary) is used. If a regular file is used as
output, its size, expressed in units of input blocks (and rounded up if
necessary) is only used when no size can be deduced for the input file.
.PP
The size of pt devices is deduced from the SCSI READ CAPACITY command.
Block device sizes (or their partition sizes) are obtained from the
operating system, if available.
.PP
If \fIskip=SKIP\fR or \fIskip=SEEK\fR are given and the \fICOUNT\fR is
deduced (i.e. not explicitly given) then that size is scaled back so
that the copy will not overrun the file or device.
.PP
If \fICOUNT\fR is not given and cannot be deduced then an error message
is issued and no copy takes place. Note that output regular files are not
truncated.
.SH CONVERSIONS
One or more conversions can be given to the "conv=" option. If more than
one is given, they should be comma separated. ddpt does not perform the
traditional dd conversions (e.g. ASCII to EBCDIC). Recently added
conversions overlap somewhat with the flags so some conversions are
now supported by ddpt.
.TP
noerror
this conversion is very close to "iflag=coe" and is treated as such. See
the "coe" flag. Note that an error on \fIOFILE\fR will stop the copy.
.TP
null
has no affect, just a placeholder.
.TP
resume
See "resume" in the FLAGS sections for more information.
.TP
sparing
See "sparing" in the FLAGS sections for more information.
.TP
sparse
FreeBSD supports "conv=sparse" so the same syntax is supported in ddpt.
See "sparse" in the FLAGS sections for more information.
.SH FLAGS
A list of flags and their meanings follow. The flag name is followed
by one or two indications in square brackets. The first indication is
either "[i]", "[o]" or "[io]" indicating this flag is active for the
\fIIFILE\fR, \fIOFILE\fR or both the \fIIFILE\fR and the \fIOFILE\fR. The
second indication contains some combination of "reg", "blk" or "pt"
indicating whether the flag applies to a regular file, a block
device (accessed via Unix read() and write() commands) or a pass\-through
device.
.TP
append [o] [reg]
causes the O_APPEND flag to be added to the open of \fIOFILE\fR. For regular
files this will lead to data appended to the end of any existing data.
Cannot be used together with the \fIseek=SEEK\fR option as they conflict.
The default action of this utility is to overwrite any existing data
from the beginning of the file or, if \fISEEK\fR is given, starting at
block \fISEEK\fR. Note that attempting to 'append' to a device file (e.g.
a disk) will usually be ignored or may cause an error to be reported.
.TP
coe [io] [pt]
continue on error. 'iflag=coe oflag=coe' and 'coe=1' are equivalent. A
medium, hardware or blank check error while reading will re\-read blocks
prior to the bad block, then try to recover the bad block, supplying zeros
if that fails, and finally reread the blocks after the bad block. A
medium, hardware or blank check error while writing is noted and ignored.
SCSI disks may automatically try and remap faulty sectors (see the AWRE
and ARRE in the read write error recovery mode page (the sdparm utility
can access these attributes)).
Unrecovered errors are counted and output in the summary at the end of
the copy. If bad LBAs are reported by the pass\-through then the LBA of the
lowest and highest bad block is also output. Errors occurring on other
file types will stop ddpt. Error messages are sent to stderr. This flag
is similar to 'conv=noerror,sync' in the
.B dd(1)
utility.
.TP
direct [io] [reg,blk]
causes the O_DIRECT flag to be added to the open of \fIIFILE\fR and/or
\fIOFILE\fR. This flag requires some memory alignment on IO. Hence user
memory buffers are aligned to the page size. May have no effect on pt
devices. See open(2) man page.
.TP
dpo [io] [pt]
set the DPO bit (disable page out) in SCSI READ and WRITE commands. Not
supported for 6 byte cdb variants of READ and WRITE. Indicates that
data is unlikely to be required to stay in device (e.g. disk) cache.
May speed media copy and/or cause a media copy to have less impact
on other device users.
.TP
excl [io] [reg,blk]
causes the O_EXCL flag to be added to the open of \fIIFILE\fR and/or
\fIOFILE\fR. See open(2) man page.
.TP
flock [io] [reg,blk,pt]
after opening the associated file (i.e. \fIIFILE\fR and/or \fIOFILE\fR)
an attempt is made to get an advisory exclusive lock with the flock()
system call. The flock arguments are "FLOCK_EX | FLOCK_NB" which will
cause the lock to be taken if available else a "temporarily unavailable"
error is generated. An exit status of 90 is produced in the latter case
and no copy is done. See flock(2) man page.
.TP
fua [io] [pt]
causes the FUA (force unit access) bit to be set in SCSI READ and/or WRITE
commands. The 6 byte variants of the SCSI READ and WRITE commands do not
support the FUA bit.
.TP
fua_nv [io] [pt]
causes the FUA_NV (force unit access non\-volatile cache) bit to be set in
SCSI READ and/or WRITE commands. This only has an effect with pt devices.
The 6 byte variants of the SCSI READ and WRITE commands do not support the
FUA_NV bit.
.TP
nocache [io] [reg,blk]
use posix_fadvise() to advise corresponding file there is no need to fill
the file buffer with recently read or written blocks. If used with "iflag="
it will increase the read ahead on \fIIFILE\fR.
.TP
null [io]
has no affect, just a placeholder.
.TP
pt [io] [blk,pt]
causes a device to be accessed in "pt" mode. In "pt" mode SCSI commands
are sent to READ and WRITE blocks rather than standard UNIX read() and
write() commands. The "pt" mode may be implicit if the device is only
capable of passing through SCSI commands (e.g. the /dev/sg devices in
Linux). This flag is needed for device nodes that can be accessed both
via standard UNIX read() and write() commands as well as SCSI commands.
Such devices default standard UNIX read() and write() commands in the
absence of this flag.
.TP
resume [o] [reg]
when a copy is interrupted (e.g. with Control-C from the keyboard)
then using the same invocation again with the addition of "oflag=resume"
will attempt to restart the copy from the point of the interrupt (or
just before that point). It is harmless to use "oflag=resume" when
\fIOFILE\fR doesn't exist or is zero length. If the length of \fIOFILE\fR
is greater than or equal to the length implied by a copy invocation that
includes "oflag=resume" then no further data is copied.
.TP
sparing [o] [reg,blk,pt]
during the copy each \fIIBS\fR * \fIBPT\fR byte segment is read from
\fIIFILE\fR into a buffer. Then, instead of writing that buffer to
\fIOFILE\fR, the corresponding segment is read from \fIOFILE\fR into another
buffer.  If the two buffers are different, the original buffer is written to
the \fIOFILE\fR.  If the two buffers compare equal then the write to
\fIOFILE\fR is not performed. For write sparing, \fIOFILE\fR must exist, be
readable and seekable. Write sparing is useful when a write operation is
more "expensive" than a read. This is the case with flash memory devices.
Another issue with flash memory devices is that they have an upper limit on
the number of times a block can be written. The granularity of the comparison
can be reduced from the default \fIIBS\fR * \fIBPT\fR byte segment with the
the \fIOBPC\fR value given to the "bpt=" option. The finest granularity is
when \fIOBPC\fR is 1 which implies \fIOBS\fR bytes.
.TP
sparse [o] [reg,blk,pt]
after each \fIIBS\fR * \fIBPT\fR byte segment is read from \fIIFILE\fR, it
is checked to see if it is all zeros. If so, nothing is written to
\fIOFILE\fR unless this is the last segment of the transfer.
This flag requires that \fIOFILE\fR is seekable (which rules out stdout).
This flag is ignored if \fIOFILE\fR is /dev/null . Note that this utility
does not truncate the \fIOFILE\fR prior to starting to write to it. Hence it
may be advantageous to manually remove the \fIOFILE\fR if it is large prior
to using "oflag=sparse". The last segment is always written so regular files
will show the same length. Thus programs like md5sum and sha1sum will
generate the same value regardless of whether "oflag=sparse" is given or not.
When the sparse flag is given twice (i.e. "oflag=sparse,sparse") then the
last segment is only written to \fIOFILE\fR  if it is other than all zeros.
The granularity of the comparison can be reduced from the default
\fIIBS\fR * \fIBPT\fR byte segment with the the \fIOBPC\fR value given to
the "bpt=" option.
.TP
ssync [o] [pt]
if \fIOFILE\fR is in "pt" mode the the SCSI SYNCHRONIZE CACHE command is
sent to \fIOFILE\fR at the end of the transfer.
.TP
sync [io] [reg,blk]
causes the O_SYNC flag to be added to the open of \fIIFILE\fR and/or
\fIOFILE\fR. See open(2) man page.
.SH DD DIFFERENCES
Most implementations of dd read a relatively small amount of data into a
copy (or transfer) buffer then write it out to the destination, repeating
this process until the \fICOUNT\fR is exhausted. Terabyte size disks make
it impractical to copy all the data into a buffer before writing it out.
.PP
The major difference in ddpt is the addition of \fIBPT\fR to control the
size of the copy buffer. With dd, \fIIBS\fR is the size of the copy buffer
and the unit of \fISKIP\fR and \fICOUNT\fR. For ddpt \fIIBS\fR * \fIBPT\fR
is the size of the copy buffer while \fIIBS\fR is the unit of \fISKIP\fR
and \fICOUNT\fR. This allows ddpt to have its \fIIBS\fR set to the logical
block size of \fIIFILE\fR without unduly restricting the size of the copy
buffer. And setting \fIIBS\fR (and \fIOBS\fR for \fIOFILE\fR) accurately
is required when the pass\-through interface is used since with the SCSI
READ and WRITE commands the logical block size is implicit.
.PP
In dd it is unclear exactly how the copy buffer is managed, especially
when \fIIBS\fR and \fIOBS\fR are different sizes. The restriction that
ddpt places on \fIIBS\fR and \fIOBS\fR (
i.e. (((\fIIBS\fR * \fIBPT\fR) % \fIOBS\fR) == 0) ) means that a single
copy buffer can be used since its size is a multiple of both \fIIBS\fR and
\fIOBS\fR). Being able to precisely define the copy buffer size in ddpt
makes sparse writing, write sparing and trim operations simpler to
define and the user to control.
.PP
dd can do partial writes which typically occur at the end of a copy.
ddpt does not do partial writes, it writes in multiples of \fIOBS\fR.
Partial writes are difficult when \fIOFILE\fR is a block device, especially
if the pass\-through interface or the direct flag is used. While it is
possible to implement partial writes on a block device (e.g. read the
block to be partially overwritten into a buffer, copy the partial write
data over part of that buffer, then write back the buffer) it is unclear
what dd does. When block devices are not involved (e.g. copying a regular
file to another regular file) ddpt's \fIIBS\fR and \fIBPT\fR can be used
creatively to avoid partial writes (e.g. 'ddpt if=from of=to bs=1 bpt=64k').
.SH SPARSE WRITING, WRITE SPARING, TRIM AND UNMAP
Seagate Pulsar SSD has an ATA interface which supports the deterministic
reads of zero after the DATA SET MANAGEMENT command with the TRIM option.
.SH NOTES
Block devices (e.g. /dev/sda and /dev/hda) can be given for \fIIFILE\fR.
If neither 'iflag=direct' nor 'iflag=pt' is given then normal block IO
involving buffering and caching is performed. If only 'iflag=direct' is
given then the buffering and caching is bypassed (this is applicable to
both SCSI devices and ATA disks). When 'iflag=pt' is given SCSI commands
are sent to the device which bypasses most of the actions performed by the
block layer. The same applies for block devices given for \fIOFILE\fR.
.PP
\fIBPT\fR, \fIBS\fR, \fICOUNT\fR, \fIIBS\fR, \fIOBS\fR, \fISKIP\fR
and \fISEEK\fR may include one of these multiplicative suffixes:
c C *1; w W *2; b B *512; k K KiB *1,024; KB *1,000; m M MiB *1,048,576;
MB *1,000,000 . This pattern continues for "G", "T" and "P". The latter two
suffixes can only be used for \fICOUNT\fR, \fISKIP\fR and \fISEEK\fR.
Also a suffix of the form "x<n>" multiplies the leading number by <n>.
These multiplicative suffixes are compatible with GNU's dd command (since
2002) which claims compliance with the SI and with IEC 60027\-2 standards.
.PP
Alternatively numerical values can be given in hexadecimal preceded by
either "0x" or "0X" (or with a trailing "h" or "H"). When hex numbers are
given, multipliers cannot be used.
.PP
The \fICOUNT\fR, \fISKIP\fR and \fISEEK\fR arguments can take 64 bit
values (i.e. very big numbers). Other numerical values are limited to what
can fit in a signed 32 bit number.
.PP
All informative, warning and error output is sent to stderr so that
dd's output file can be stdout and remain unpolluted. If no options
are given, then the usage message is output and nothing else happens.
.PP
Disk partition information can often be found with
.B fdisk(8)
[the "\-ul" argument is useful in this respect]. Also
.B parted(8)
can be used like this: 'parted /dev/sda unit s print' .
.PP
For pt devices this utility issues SCSI READ and WRITE (SBC) commands which
are appropriate for disks and reading from CD/DVD/HD\-DVD/BD drives. Those
commands are not formatted correctly for tape devices so ddpt should not be
used on tape devices. If the largest block address of the requested transfer
exceeds a 32 bit block number (i.e 0xffff) then a warning is issued and
the sg device is accessed via SCSI READ(16) and WRITE(16) commands.
.PP
The attributes of a block device (partition) are ignored when the pt flag
is used. Hence the whole device is read (rather than just the second
partition) by this invocation:
.PP
   ddpt if=/dev/sdb2 iflag=pt of=t bs=512
.SH EXAMPLES
.PP
ddpt usage looks quite similar to dd:
.PP
   ddpt if=/dev/sg0 of=t bs=512 count=1MB
.PP
This will copy 1 million 512 byte blocks from the device associated with
/dev/sg0 (which should have 512 byte blocks) to a file called t.
Assuming /dev/sda and /dev/sg0 are the same device then the above is
equivalent to:
.PP
   dd if=/dev/sda iflag=direct of=t bs=512 count=1000000
.PP
although dd's speed may improve if bs was larger and count was suitably
reduced. The use of the 'iflag=direct' option bypasses the buffering and
caching that is usually done on a block device.
.PP
The dd command's bs argument can be thought of as roughly equivalent to
ddpt's bs*bpt . dd almost assumes buffering on a block device and will
work as long as bs is a multiple of the actual logical block size.
Since ddpt can work at a lower level in some cases the bs argument must be
a disk's actual logical block size. Thus the bpt argument was introduced
to make the copy more efficient. So these two invocations are roughly
equivalent:
.PP
   dd if=/dev/sda of=t bs=8k count=64
.br
   ddpt if=/dev/sda of=t bs=512 bpt=16 count=1k
.PP
In both cases the total number of bytes moved is bs*count . And that will
be done by reading 8k (8192 bytes) into a buffer than writing out that
buffer to the file t. The read write sequence continues until the
count is complete or an error occurs.
.PP
The 'of2=' option can save time when the input needs to be read twice.
For example, to copy data and take a md5sum of it without needing to
re\-read the data:
.PP
  mkfifo fif
.br
  md5sum fif &
.br
  ddpt if=/dev/sg3 iflag=coe of=sg3.img oflag=sparse of2=fif bs=512
.PP
This will image /dev/sg3 (e.g. an unmounted disk) and place the contents
in the (sparse) file sg3.img . Without re\-reading the data it will also
perform a md5sum calculation on the image.
.PP
Now we use sparse writing logic to check if every block on a disk
is full of zeros. This may be the case after a SCSI FORMAT or an ATA
SECURITY ERASE command.
.PP
   ddpt if=/dev/sdc bs=512 oflag=sparse,sparse
.PP
The "sparse,sparse" suppresses the forced write of the last segment.
Since no "of=" option is given, output goes to /dev/null so nothing
is actually written. However there is still a count of "records out"
and "bypassed records out". If /dev/sdc is full of zeros then
the "records out" count should be zero.
.SH SIGNALS
The signal handling has been borrowed from dd: SIGINT, SIGQUIT and
SIGPIPE output the number of remaining blocks to be transferred and
the records in + out counts; then they have their default action.
SIGUSR1 causes the same information to be output and the copy continues.
All output caused by signals is sent to stderr.
.SH EXIT STATUS
To aid scripts that call ddpt, the exit status is set to indicate
success (0) or failure (1 or more). Note that some of the lower values
correspond to the SCSI sense key values. The exit status values are:
.TP
.B 0
success
.TP
.B 1
syntax error. Either illegal command line options, options with bad
arguments or a combination of options that is not permitted.
.TP
.B 2
the device reports that it is not ready for the operation requested.
The device may be in the process of becoming ready (e.g.  spinning up but
not at speed) so the utility may work after a wait.
.TP
.B 3
the device reports a medium or hardware error (or a blank check). For example
an attempt to read a corrupted block on a disk will yield this value.
.TP
.B 5
the device reports an "illegal request" with an additional sense code other
than "invalid operation code". This is often a supported command with a
field set requesting an unsupported capability.
.TP
.B 6
the device reports a "unit attention" condition. This usually indicates
that something unrelated to the requested command has occurred (e.g. a
device reset) potentially before the current SCSI command was sent. The
requested command has not been executed by the device. Note that unit
attention conditions are usually only reported once by a device.
.TP
.B 9
the device reports an illegal request with an additional sense code
of "invalid operation code" which means that it doesn't support the
requested command.
.TP
.B 11
the device reports an aborted command. In some cases aborted commands can
be retried immediately (e.g. if the transport aborted the command due to
congestion).
.TP
.B 15
the utility is unable to open, close or use the given \fIIFILE\fR or
\fIOFILE\fR. The given file name could be incorrect or there may be
permission problems. Adding the \fI\-v\fR option may give more information.
.TP
.B 20
the device reports it has a check condition but "no sense".
It is unlikely that this value will occur as an exit status.
.TP
.B 21
the device reports a "recovered error". The requested command was successful.
Most likely a utility will report a recovered error to stderr and continue,
probably leaving the utility with an exit status of 0 .
.TP
.B 33
the command sent to device has timed out. This occurs in Linux only; in
other ports a command timeout will appear as a transport (or OS) error.
.TP
.B 90
the flock flag has been given on a device and some other process holds the
advisory exclusive lock.
.TP
.B 97
the response to a SCSI command failed sanity checks.
.TP
.B 98
the device reports it has a check condition but the error doesn't fit into
any of the above categories.
.TP
.B 99
any errors that can't be categorized into values 1 to 98 may yield
this value. This includes transport and operating system errors
after the command has been sent to the device.
.SH AUTHORS
Written by Doug Gilbert
.SH "REPORTING BUGS"
Report bugs to <dgilbert at interlog dot com>.
.SH COPYRIGHT
Copyright \(co 2008\-2010 Douglas Gilbert
.br
This software is distributed under the GPL version 2. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
.SH "SEE ALSO"
There is a web page discussing ddpt at http://sg.danny.cz/sg/ddpt.html
.PP
The lmbench package contains
.B lmdd
which is also interesting. For moving data to and from tapes see
.B dt
which is found at http://www.scsifaq.org/RMiller_Tools/index.html
.PP
To change mode parameters that effect a SCSI device's caching and error
recovery see
.B sdparm(sdparm)
.PP
To scan and repair disk partitions see TestDisk (testdisk).
.PP
Additional references:
.B dd(1), ddrescue(GNU), open(2), flock(2), sg_dd(sg3_utils)
