<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>ddpt utility (a Unix dd command variant)</title>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="keywords"
 content="ddpt, dd variant, pass-through, file copy">
  <meta name="GENERATOR"
 content="Mozilla/4.79 [en] (X11; U; Linux 2.5.31 i686) [Netscape]">
</head>
<body alink="#ff0000" background="paper.jpg" bgcolor="#ffffff"
 link="#0000ff" text="#000000" vlink="#000080">
<center>
<h1><a class="mozTocH1" name="mozTocId228087"></a> The&nbsp;
ddpt utility<br>
</h1>
</center>
<a href="#Conclusion"></a>
<ol id="mozToc">
<!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->
  <li><a href="#mozTocId228087"> The&nbsp;
ddpt utility </a>
    <ol>
      <li><a href="#mozTocId370866">Introduction</a></li>
      <li><a href="#mozTocId123443">History</a></li>
      <li><a href="#mozTocId352668">dd like features</a></li>
      <li><a href="#mozTocId703997">ddpt extra options</a></li>
      <li><a href="#mozTocId657084">Retries</a></li>
      <li><a href="#mozTocId437677">Continue on error
(coe)</a></li>
      <li><a href="#mozTocId566094">Recovered errors</a></li>
      <li><a href="#mozTocId836611">Sparse writes and
write sparing </a></li>
      <li><a href="#mozTocId899152">Verbose</a></li>
      <li><a href="#mozTocId415792">Examples</a></li>
    </ol>
  </li>
</ol>
<h2><a class="mozTocH2" name="mozTocId370866"></a>Introduction</h2>
The <span style="font-weight: bold;">ddpt</span> utility is a variant
of the standard Unix command <span style="font-weight: bold;">dd</span>
which
copies files. The <span style="font-weight: bold;">ddpt</span> utility
is specialized for files that are block
devices. Even finer grain control can be applied if those block devices
understand the SCSI command sets which are accessed via a so-called
"pass-through". The <span style="font-weight: bold;">ddpt</span>
utility is
found in the package of the same name. Although it was developed on
Linux, <span style="font-weight: bold;">ddpt</span> targets various
Unix based operating systems and
Windows.<br>
<br>
The supported SCSI peripheral device
types are direct access devices (e.g. disks) and cd/dvd devices. The
SCSI tape device type is not be supported. When instructed, the ddpt
utility issues SCSI
commands that are defined in SPC-4 (primary commands), SBC-3 (commands
for direct access devices (e.g. disks)) and MMC-5 (commands for CD/DVD
devices). These SCSI command sets can be found at <a
 href="http://www.t10.org/">www.t10.org</a>
. <br>
<br>
It is becoming common for non-SCSI storage devices (e.g. ATA disks) to
appear
as SCSI devices to an operating system via a protocol conversion in an
external enclosure or via some transport such as USB or IEEE 1394. The
ddpt utility should work with most of these devices as it tends to use
exactly the same SCSI commands that the operating system's block layer
would use.
However, advanced options (e.g. using the cdbsz=16 and iflag=fua) most
likely will be ignored. Apart from CD players over 10 years old, almost
all CD/DVD players use the Multi Media Command set (MMC or&nbsp;
MMC-2,3,4,5,6) as their native command set. The fact that the most
common
transport for CD/DVD drives is ATAPI (i.e. the ATA packet interface) is
irrelevant in this context: SCSI command sets are being used.<br>
<br>
This page outlines the features of the ddpt utility version 0.90 .<br>
<br>
<h2><a class="mozTocH2" name="mozTocId123443"></a>History</h2>
The ddpt utility is a more generic version of the <a href="sg_dd.html">sg_dd</a>
utility found in the <a href="sg3_utils.html">sg3_utils</a> package.
The sg_dd utility is Linux specific, using the Linux SCSI generic
driver for passing through SCSI commands to block devices. Although
SCSI
command pass-through mechanisms are found in most operating systems,
the sg_dd utility&nbsp; has options to control some special features
associated with the sg driver and the SG_IO ioctl in Linux.<br>
<br>
Where a block device could either be accessed via normal UNIX
read-write commands (the default) or the SCSI pass-through mechanism,
"sg" appearing in options or flags of sg_dd has been changed to "pt" in
this utility. For example requesting the SCSI pass-through "if=/dev/sda
iflag=sgio" in sg_dd has become "if=/dev/sda iflag=pt" in ddpt.<br>
<br>
The restriction that the input block size ('ibs=') and output block
size ('obs=') be the same value in the sg_dd utility has been relaxed
in this utility. New features such as write sparing are more
likely to appear in this utility than the sg_dd utility.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId352668"></a>dd like features</h2>
The basic syntax of the ddpt utility is the same as the dd command in
Unix. That said, the syntax of the dd command in Unix is different from
almost all other Unix commands. Those familiar with the dd
command
should not be too surprised by the syntax and semantics of this
utility. Those not familiar with the dd syntax should be very careful,
especially with the 'of=' and 'seek=' options, both with dd and ddpt.
The recent GNU implementation of the dd command is used as a reference
point. The fundamental options of dd are:<br>
<br>
<table style="width: 100%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
  <caption align="bottom"><span style="font-weight: bold;">Table
1&nbsp;
Fundamental dd options</span><br>
  </caption> <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Basic
dd option</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Default</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Brief
description</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">bs=<span
 style="font-style: italic;">BS</span><br>
      </td>
      <td style="vertical-align: top;">512<br>
      </td>
      <td style="vertical-align: top;">Number of bytes in each block.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">count=<span
 style="font-style: italic;">COUNT</span></td>
      <td style="vertical-align: top;">blocks in <span
 style="font-style: italic;">IFILE</span><br>
      </td>
      <td style="vertical-align: top;">Number of input blocks to copy.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">if=<span
 style="font-style: italic;">IFILE</span></td>
      <td style="vertical-align: top;">stdin<br>
      </td>
      <td style="vertical-align: top;">file (or device) to read from.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">of=<span
 style="font-style: italic;">OFILE</span></td>
      <td style="vertical-align: top;">stdout<br>
      </td>
      <td style="vertical-align: top;">file (or device) to write to. <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
When either dd or ddpt are given these options with suitable
arguments, they will copy
(<span style="font-style: italic;">BS</span> * <span
 style="font-style: italic;">COUNT</span>) bytes from the beginning
of <span style="font-style: italic;">IFILE</span> to the
beginning of <span style="font-style: italic;">OFILE</span>.<br>
<br>
The following extensions are found in ddpt. An <span
 style="font-style: italic;">IFILE</span> of
"-" is interpreted as stdin; an <span style="font-style: italic;">OFILE</span>
of "-" is
interpreted as stdout while an <span style="font-style: italic;">OFILE</span>
of "." is
interpreted as <span style="font-family: monospace;">/dev/null</span>.
[dd interprets input and output file names of
"-" literally; dd interprets an output file of "." as the current
directory and will not accept it.] The ddpt utility does not truncate
the <span style="font-style: italic;">OFILE</span> before starting the
copy (the dd command does
if it is a normal file). Hence a user may need to delete the output
file before using the ddpt utility (if the size of that file is
greater than what ddpt is going to copy over it).<br>
<br>
If the 'count=' option is not given then an attempt is made to
determine
the remaining blocks in the file, device or partition. If the input
file is stdin and no count is given then a copy will continue until an
EOF is detected on the input stream (or something else goes wrong). If
the 'count=' option is not given then the remaining blocks on both the
input and output files are determined (if possible) and if both are
found then the minimum of
the two counts is used.&nbsp; The 'skip=' option for an input file and
the 'seek=' option for an output file are taken into account when
calculating the remaining number of blocks in a file, device or
partition.<br>
<br>
If the 'count=' option is given then no further checks regarding the
remaining length of the input and output files are done and the ddpt
will attempt to copy that number of blocks. A 'count=0' option is valid
and all the normal preparations are made including opening files
but no copy takes place. Hence the 'count=0' option can be used to
check that the syntax is in order and that the files are present (see
the
"<a href="#mozTocId899152">Verbose</a>" section below). Other dd
options also supported by ddpt:<br>
<br>
<table style="width: 750px; text-align: left; height: 304px;" border="1"
 cellpadding="2" cellspacing="2">
  <caption align="bottom"><span style="font-weight: bold;">Table
2&nbsp; Other dd options also supported by ddpt</span><br>
  </caption> <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">dd
option</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Default</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Brief
description</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">conv=<span
 style="font-style: italic;">CONV</span><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">only one <span
 style="font-style: italic;">CONV</span> supported: sparse. Same action
as 'oflag=sparse'.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">ibs=<span
 style="font-style: italic;">BS</span></td>
      <td style="vertical-align: top;">same as bs=<span
 style="font-style: italic;">BS</span><br>
      </td>
      <td style="vertical-align: top;">number of bytes in each block of
      <span style="font-style: italic;">IFILE</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">iflag=<span
 style="font-style: italic;">FLAGS</span><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">similar
to option found in recent GNU dd versions, see below<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">obs=<span
 style="font-style: italic;">OBS</span></td>
      <td style="vertical-align: top;">same as bs=<span
 style="font-style: italic;">BS</span><br>
      </td>
      <td style="vertical-align: top;">number of bytes in each block of
      <span style="font-style: italic;">OFILE</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;">oflag=<span
 style="font-style: italic;">FLAGS</span><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">similar
to option found in recent GNU dd versions, see below<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">seek=<span
 style="font-style: italic;">SEEK</span></td>
      <td style="vertical-align: top;">0<br>
      </td>
      <td style="vertical-align: top;">block number (origin 0) in <span
 style="font-style: italic;">OFILE</span> to commence writing<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">skip=<span
 style="font-style: italic;">SKIP</span></td>
      <td style="vertical-align: top;">0<br>
      </td>
      <td style="vertical-align: top;">block number (origin 0) in <span
 style="font-style: italic;">IFILE</span> to commence reading</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">--help<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">print usage message then exit<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">--version<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;">print version number and its
date then exit<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
The 'bs=BS' and 'ibs=BS' options can be viewed as synonyms. If both
'ibs=BS'
and 'obs=OBS' are given and differ then (BS * BPT) must be divisible by
OBS, without any remainder. [BPT is input "blocks per transfer" and is
explained below.]&nbsp; The 'skip=SKIP' option
cannot be
used on an input stream
(e.g. stdin) while the 'seek=SEEK' option cannot be used on an output
stream
(e.g. stdout).<br>
<br>
All numeric arguments can take a multiplier suffix. These multiplier
suffixes are the same as those of GNU's dd (posted 2001-12-18):<br>
<br>
<table style="width: 50%; text-align: left;" border="1" cellpadding="2"
 cellspacing="2">
  <caption align="bottom"><span style="font-weight: bold;">Table
3&nbsp; Multiplier suffixes for numeric arguments</span><br>
  </caption> <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Multiplier</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Meaning
multiply associated number by</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">x&lt;n&gt;<br>
      </td>
      <td style="vertical-align: top;">&lt;n&gt;<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">c<br>
      </td>
      <td style="vertical-align: top;">1<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">w<br>
      </td>
      <td style="vertical-align: top;">2<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">b<br>
      </td>
      <td style="vertical-align: top;">512<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">k&nbsp; K&nbsp; KiB<br>
      </td>
      <td style="vertical-align: top;">1024<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">KB<br>
      </td>
      <td style="vertical-align: top;">1000<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">m&nbsp; M&nbsp; MiB<br>
      </td>
      <td style="vertical-align: top;">1048576 </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">MB<br>
      </td>
      <td style="vertical-align: top;">1000000<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">g&nbsp; G&nbsp; GiB<br>
      </td>
      <td style="vertical-align: top;">2**30<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">GB<br>
      </td>
      <td style="vertical-align: top;">10**9<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">t&nbsp; T&nbsp; TiB<br>
      </td>
      <td style="vertical-align: top;">2**40 </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">TB<br>
      </td>
      <td style="vertical-align: top;">10**12<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
The pattern that starts with "k" and proceeds to "m", "g" and "t" then
to "p", "e", "z" and "y"&nbsp; (not shown in above table). ddpt only
implements as far as "p" (10**15 or 2**50). ddpt only allows
multipliers based on "t" and "p" for 'count', 'skip' and 'seek'.<br>
<br>
ddpt allows numeric arguments to be given in hexadecimal in which case
they must be prefixed by either "0x" or "0X". A numeric argument cannot
both be in hex and have a suffix multiplier. Hence "0x9" is interpreted
as hexadecimal 9 [not (0 * 9)==0]. This string is valid: "2x4x0xa" and
yields
80 (but it isn't very clear).<br>
<br>
Hexadecimal numbers
can also be indicated by a trailing "h" or "H". The "h" suffix cannot
be used together with a suffix multiplier.<br>
<br>
The <span style="font-style: italic;">FLAGS</span> argument of
'iflag=' and 'oflag=' is a comma
separated list of items chosen from one or more entries in this table:<br>
<br>
<table style="width: 705px; text-align: left; height: 494px;" border="1"
 cellpadding="2" cellspacing="2">
  <caption align="bottom"><span style="font-weight: bold;">Table
4&nbsp; Arguments to ddpt's iflag and oflag options</span><br>
  </caption> <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">flag</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">pt
device</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">block
device</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">regular
file</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">comments</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">append<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">applied on <span
 style="font-style: italic;">OFILE</span><br>
      </td>
      <td style="vertical-align: top;">applied on <span
 style="font-style: italic;">OFILE</span><br>
      </td>
      <td style="vertical-align: top;">use O_APPEND open flag.
Conflicts with 'seek=<span style="font-style: italic;">SEEK</span>'
when "<span style="font-style: italic;">SEEK</span> &gt; 0"<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">coe<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">ignored</td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">continue on error; best effort
recovery then continue. See section on <a
 href="ddpt.html#mozTocId437677">continue
on error</a>. </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">direct<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">use O_DIRECT open flag, no
effect with pass-through devices<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">dpo<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">ignored</td>
      <td style="vertical-align: top;">ignored</td>
      <td style="vertical-align: top;">"disable page out" set for READ
and/or WRITE SCSI commands</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">excl<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">Use O_EXCL open flag<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">fua<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">"force unit access" set for READ
and/or WRITE SCSI commands<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">fua_nv<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">"force unit access non-volatile
cache" set for READ and/or WRITE SCSI commands<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">nocache<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">Use
posix_fadvise(POSIX_FADV_DONTNEED) to suggest minimal use of file
buffers (kernel
cache) associated with files being copied.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">null<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">this flag is just a place holder<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">pt<br>
      </td>
      <td style="vertical-align: top;">active<br>
      </td>
      <td style="vertical-align: top;">try<br>
      </td>
      <td style="vertical-align: top;">-<br>
      </td>
      <td style="vertical-align: top;">access block device via SCSI
pass-through mechanism<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">sparing<br>
      </td>
      <td style="vertical-align: top;">applied on <span
 style="font-style: italic;">OFILE</span></td>
      <td style="vertical-align: top;">applied on <span
 style="font-style: italic;">OFILE</span></td>
      <td style="vertical-align: top;">applied on <span
 style="font-style: italic;">OFILE</span></td>
      <td style="vertical-align: top;">don't write output buffers if
reading the output indicates the data compares equal. See section on <a
 href="ddpt.html#mozTocId836611">sparse writes and write sparing</a> </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">sparse<br>
      </td>
      <td style="vertical-align: top;">applied on <span
 style="font-style: italic;">OFILE</span><br>
      </td>
      <td style="vertical-align: top;">applied on <span
 style="font-style: italic;">OFILE</span><br>
      </td>
      <td style="vertical-align: top;">applied on <span
 style="font-style: italic;">OFILE</span><br>
      </td>
      <td style="vertical-align: top;">don't write output buffers
(except the last one) that are full of zeros. See section on <a
 href="#mozTocId836611">sparse writes and write sparing</a> .<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">ssync<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">ignored<br>
      </td>
      <td style="vertical-align: top;">send SCSI SYNCHRONIZE CACHE
command to <span style="font-style: italic;">OFILE</span> after copy<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">sync<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">applied<br>
      </td>
      <td style="vertical-align: top;">use O_SYNC open flag</td>
    </tr>
  </tbody>
</table>
<br>
Recent versions of GNU's dd command have these flags with similar
semantics:&nbsp; 'append', 'direct' and 'sync'. These flags are ddpt
extensions: 'coe', 'dpo', 'excl', 'fua', 'nocache', 'null', 'pt',
'sparing', 'sparse' and 'ssync'.<br>
<br>
The following dd options are <span style="font-weight: bold;">not</span>
supported by ddpt:<br>
<ul>
  <li>cbs=&lt;bytes&gt;</li>
  <li>conv=&lt;keyword(s)&gt;</li>
</ul>
with one exception, 'conv=sparse' is accepted as a synonym for
'oflag=sparse'. Basically ddpt does not support the conversion features
of dd. If a
conversion is needed then ddpt could be piped through dd (or
vice versa).<br>
<h2><a class="mozTocH2" name="mozTocId703997"></a>ddpt extra options</h2>
The extra options of ddpt (not found in GNU's dd) are:<br>
<ul>
</ul>
<table style="width: 731px; text-align: left; height: 610px;" border="1"
 cellpadding="2" cellspacing="2">
  <caption align="bottom"><span style="font-weight: bold;">Table
5&nbsp; Extra options found in ddpt</span><br>
  </caption> <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">extra
option in ddpt</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">default</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Brief
description</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">bpt=<span
 style="font-style: italic;">BPT</span><br>
      </td>
      <td style="vertical-align: top;">128 or 32<br>
      </td>
      <td style="vertical-align: top;">where <span
 style="font-style: italic;">BPT</span> is the number of input blocks
per transfer
(granularity
of each IO). Default is 128 when <span style="font-style: italic;">BS</span>
&lt; 2048 (bytes) else the default
is 32.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">cdbsz=6 | 10 | 12 | 16<br>
      </td>
      <td style="vertical-align: top;">10 or 16<br>
      </td>
      <td style="vertical-align: top;">cdb size of SCSI READ and/or
WRITE commands. Only applicable to pt devices. Defaults to 10 byte cdb
unless
the largest address exceeds 32 bits or <span
 style="font-style: italic;">BPT</span> exceeds 16 bits. In either
case a 16 cdb is used.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">coe=0 | 1<br>
      </td>
      <td style="vertical-align: top;">0<br>
      </td>
      <td style="vertical-align: top;">when non-zero, continue_on_error
for pt devices. May use iflag=coe
and/or oflag=coe
instead. See section on <a href="#mozTocId437677">continue on error</a>.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">coe_limit=<span
 style="font-style: italic;">CL</span><br>
      </td>
      <td style="vertical-align: top;">0<br>
      </td>
      <td style="vertical-align: top;">number of consecutive "bad"
block errors allowed when reading and 'coe &gt; 0'. Default of 0 is
interpreted as no limit. See section on <a
 href="ddpt.html#mozTocId437677">continue on error</a>.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">of2=<span
 style="font-style: italic;">OFILE2</span><br>
      </td>
      <td style="vertical-align: top;">/dev/null<br>
      </td>
      <td style="vertical-align: top;">second output file. Cannot be pt
device.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">retries=<span
 style="font-style: italic;">RETR</span><br>
      </td>
      <td style="vertical-align: top;">0<br>
      </td>
      <td style="vertical-align: top;">number of times to retry an
error on a sg device READ or WRITE command<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">time=0 | 1<br>
      </td>
      <td style="vertical-align: top;">1<br>
      </td>
      <td style="vertical-align: top;">when set print elapsed time and
throughput calculation at the completion of the copy. Note the default
is to time.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">verbose=<span
 style="font-style: italic;">VERB</span><br>
      </td>
      <td style="vertical-align: top;">0<br>
      </td>
      <td style="vertical-align: top;">larger <span
 style="font-style: italic;">VERB</span> is the greater
the debug output. 1 and 2 print the cdbs for setup commands; 3 and 4
print the cdbs for all commands<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
The ddpt utility examines the files it is given and treats them
differently depending on their file type. Depending on iflag=<span
 style="font-style: italic;">FLAGS</span> and oflag=<span
 style="font-style: italic;">FLAGS</span> settings: O_DIRECT,
O_SYNC, O_APPEND and O_EXCL flags may be added to the relevant open
system
call. In Unix see 'man 2 open' or 'man -s 2 open' for more information
on the open system call.<br>
<br>
<table style="width: 740px; text-align: left; height: 375px;" border="1"
 cellpadding="2" cellspacing="2">
  <caption align="bottom"><span style="font-weight: bold;">Table
6&nbsp; Treatment of various file types by ddpt</span><br>
  </caption> <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">File
type</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">open
[when input]</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">open
[when output]</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">IO
method</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Notes</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">normal<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY<br>
      <br>
      </td>
      <td style="vertical-align: top;">O_WRONLY | O_CREAT<br>
      </td>
      <td style="vertical-align: top;">Unix read() write()<br>
      </td>
      <td style="vertical-align: top;">N.B. A normal output file is
overwritten (not truncated).<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">stdin or stdout<br>
      </td>
      <td style="vertical-align: top;">[do nothing]<br>
      </td>
      <td style="vertical-align: top;">[do nothing]<br>
      </td>
      <td style="vertical-align: top;">Unix read() write()<br>
      </td>
      <td style="vertical-align: top;">hence open() flags have no
effect (e.g. 'oflag=direct' is ignored)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span
 style="font-family: monospace;">/dev/null</span> or . (period)<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">[do nothing]<br>
      </td>
      <td style="vertical-align: top;">Unix read() if input<br>
      </td>
      <td style="vertical-align: top;">if output file then nothing is
written<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">block device<br>
      </td>
      <td style="vertical-align: top;">O_RDONLY</td>
      <td style="vertical-align: top;">O_WRONLY | O_CREAT<br>
      </td>
      <td style="vertical-align: top;">Unix read() write()</td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">pt device<br>
      </td>
      <td style="vertical-align: top;">O_RDWR or O_RDONLY<br>
      </td>
      <td style="vertical-align: top;">O_RDWR<br>
      </td>
      <td style="vertical-align: top;">SCSI commands<br>
      </td>
      <td style="vertical-align: top;">Opens input O_RDONLY if O_RDWR
fails</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">scsi tape device<br>
      </td>
      <td style="vertical-align: top;">x<br>
      </td>
      <td style="vertical-align: top;">x<br>
      </td>
      <td style="vertical-align: top;">no IO<br>
      </td>
      <td style="vertical-align: top;">error reported<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
Some of the above combinations are not sensible (e.g. append=1 on a
block device). When either 'iflag=direct' or 'oflag=direct' is given
(hence opening the corresponding file with O_DIRECT) the internal
buffer used is aligned to the page size. For example the page size in
the Linux i386 architecture is 4
kilobytes.<br>
<br>
Depending on the platform when a file is known to be associated with
the pass-through interface (e.g. in Linux "/dev/sg2") the "pt" flag is
assumed. This implies that in Linux if 'if=/dev/sg2' is specified then
there is no need to add 'iflag=pt'. On the other hand if the file
appears to be a block device (e.g. in Linux "/dev/sdc") then the normal
read()/write() system calls will be used unless 'iflag=pt' (or
'oflag=pt') is given.<br>
<br>
With block and pt devices the operating system may impose an upper
limit on the size of each IO operation. The size that ddpt will attempt
to use is <span style="font-style: italic;">BS*BPT</span> bytes. If
this limit is exceeded the operating system may well respond with an
EIO (input/output)
error. In such cases try reducing the <span style="font-style: italic;">BPT</span>
value.<br>
<br>
If a partition of block device is accessed (e.g. in Linux <span
 style="font-family: monospace;">/dev/sda2</span>) and the "pt" flag is
not given then logical block address 0 for the
purposes of ddpt (and its skip and seek options) is the beginning of
that partition while the calculated count (e.g. when a 'count' option
is not given) is the extent of that partition. However if a partition
of a block device is accessed (e.g. in Linux<span
 style="font-family: monospace;"> /dev/sda2</span>)
when the "pt" flag is active then the
partition is ignored and the underlying device is accessed. This means
logical block address 0 for the purposes of ddpt (and its skip and
seek options) is the beginning of the device while the calculated count
(e.g. when a 'count=' option is not given) is the extent of that device.<br>
<br>
If a SIGUSR1 signal is sent to the process identifier (pid) of a
running ddpt utility then the number of blocks copied to that point is
output. The copy continues.<br>
<br>
Unless the 'time=0' option is given, the elapsed time for the copy plus
the
throughput measured in megabytes (10**6 bytes)&nbsp; per second is
output when the copy is complete (or an error stops the copy). If a
SIGUSR1 signal is sent to the process identifier (pid) of a running
ddpt utility then the elapsed time and the
throughput of the copy to that point is output and the copy continues.<br>
<h2><a class="mozTocH2" name="mozTocId657084"></a>Retries</h2>
Often retries are of little use, especially on medium errors, since the
device has probably already done multiple retries (probably
interspersed with moving the heads to the extreme ends of the media)
before the medium error is reported. However a transport error (e.g.
causing a CRC error in returned data) is not necessarily seen by the
device and a retry may quickly solve the problem. In SAS a Transport
Layer Retries (TLR) state machine is optional and requires both the
initiator and target to implement the capability. Most first generation
SAS disks do not implement TLR. So transport errors in the form of
"aborted commands" can be reported due to corruption (e.g. due to
marginal cables)
or congestion.<br>
<br>
When the retries=<span style="font-style: italic;">RETR</span> option
is given and <span style="font-style: italic;">RETR</span> is greater
than 0 then most errors on a READ or WRITE SCSI command are retried up
to <span style="font-style: italic;">RETR</span> times. Device not
ready errors are not retried and "unit
attention" conditions are automatically retried (without looking at or
decrementing <span style="font-style: italic;">RETR</span>). Once the
number of retries is exhausted on the
same operation without success then ddpt will refer to the 'coe'
option as to what to do next. Each new operation, READ or WRITE, or to
a different logical block address has its own
retry count initialized to <span style="font-style: italic;">RETR</span>.<br>
<h2><a class="mozTocH2" name="mozTocId437677"></a>Continue on error
(coe)</h2>
The ddpt utility may be used as a copy "of
last resort" from failing media. Read errors on an input file
taking SCSI commands are "tolerated" when the 'coe' option is non-zero.
Write errors from SCSI commands are reported and ignored and the ddpt
utility continues when the 'coe' option is non-zero. [In the case where
media errors are causing write errors the user should check the setting
of the AWRE bit in the SCSI "read write
error recovery" mode page (see SBC-3 at <a href="http://www.t10.org">http://www.t10.org</a>).]<br>
<br>
When a SCSI READ command detects an unrecoverable read error it
responds with a sense key of MEDIUM ERROR or HARDWARE ERROR.
Additionally it responds with the logical block address of the first
(lowest) block that it failed to read in the current READ command. Any
valid blocks prior to the "bad" block may or may not have been
transferred (depending on several other settings). If coe=0 then the
ddpt utility will simply terminate at this point (with a reasonable
amount of debug information sent to stderr) <span
 style="font-weight: bold;">and</span> good blocks prior to the bad
block may not be copied (depending on the setting of <span
 style="font-style: italic;">BPT</span>). If 'coe'
is non-zero then the first
thing ddpt will try to do is a truncated read up to, but not
including,
the
bad block. <br>
<br>
There still remain blocks after the "bad" block that need to be
fetched. Further bad blocks may be detected and if so
the algorithm in the last paragraph is repeated. The result of
this
process is an imperfect copy with blocks that were read properly placed
in the correct relative position in the output. When the coe=1 option
is given an additional counter is <br>
output on completion: unrecovered errors. This is the number of
unrecovered (read) errors
encountered. Any number greater than zero indicates an imperfect copy.<br>
<br>
The standard <span style="font-weight: bold;">dd</span> command also
has a "continue on error" facility. The next two invocations are
roughly the same:<br>
<span style="font-family: monospace;">&nbsp; ddpt if=/dev/sda
iflag=pt,coe of=sda.img bs=512</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; dd if=/dev/sda
iflag=direct of=sda.img bs=512 conv=noerror,sync</span><br>
Without 'count=&lt;n&gt;' options the whole of /dev/sda will be copied
to <span style="font-family: monospace;">sda.img</span> . The
'noerror' argument to 'conv=' tells <span style="font-weight: bold;">dd</span>
to continue on error and the 'sync' tells it to supply zeros for blocks
that can not be read.
If the latter step is not done the image file will be shorter when
errors are detected.<br>
<br>
The coe_limit=<span style="font-style: italic;">CL</span> option is
meant to stop ddpt continuing ad
nausum if errors are being detected during reading. The input media may
be blank (unrecorded) or beyond its logical block address limit. The
coe_limit=<span style="font-style: italic;">CL</span> option is only
active on read operations when
'coe &gt; 0' which itself is only active on pt device nodes.<br>
<br>
Another dd variant called <span style="font-weight: bold;">dd_rescue</span>
(see <a href="http://www.garloff.de/kurt/linux/ddrescue/">www.garloff.de/kurt/linux/ddrescue/
</a>) has similar "continue on error" facilities. <br>
<br>
<h2><a class="mozTocH2" name="mozTocId566094"></a>Recovered errors</h2>
Often errors are recovered using ECC data or by the device retrying
(usually re-reading) the media. Typically at the first sign of trouble,
recoverable errors lead to the block in question being reassigned to
another location on the media (automatically when the AWRE and ARRE
bits are set in the "read write error recovery" mode page).&nbsp; The
user of such a disk may be blissfully unaware that the disk may be
reaching the end of its useful life. Error counters are maintained in
the "Read error counter" and "Write error counter" logs pages which can
be viewed with smartctl (from smartmontools) and sg_logs (from the
sg3_utils package). Any block that is
automatically or manually re-assigned adds a new entry to the "grown"
defect list which can be viewed with '<span
 style="font-family: monospace;">sginfo -G</span>' or '<span
 style="font-family: monospace;">sg_reassign -g</span>'
(both found in the
sg3_utils package).<br>
<br>
A disk can be instructed to report RECOVERED ERRORs by setting the PER
bit in the "read write error recover" mode page. Most often this bit is
clear. When ddpt detects RECOVERED ERRORs it reports them, counts
them and continues the copy. Only the lba of the last recovered error
in a READ or WRITE SCSI
command is reported so there could be more than one recovered error per
SCSI command. The bpt=1 option
could be chosen to limit every SCSI command to a single block transfer
(but that would slow things down a fair amount). If the count of
recovered errors is greater than zero at the end of the copy then this
count is output as well.<br>
<br>
There can be other reasons for a sense key of RECOVERED ERROR not
directly related to data being currently read or written. SMART alerts
(called in SCSI documents "Informational Exceptions") can be conveyed
via a RECOVERED ERROR sense key (see the MRIE field in the
Informational Exceptions mode page). Such alerts have additional sense
codes like "Failure prediction threshold exceeded" and those that
contain "impending failure".<br>
<br>
<h2><a class="mozTocH2" name="mozTocId836611"></a>Sparse writes and
write sparing<br>
</h2>
Typically disks are manufactured with their data sectors initialized to
zero bytes. In some cases a DOS partition table and boot loader are
written during manufacture but that only involves the first 63 sectors.
If the user wants
to image such a disk, or a partition on that disk, to a file then the
file system needs to create a file of the same size as the disk or
partition. With the availability of 1 terabyte disks that would be a
very big file which might be 99% full of zeros.<br>
<br>
Unix file systems usually allow the file pointer to be moved (e.g. with
the
<span style="font-family: monospace;">lseek()</span> system call)
around arbitrarily. Moving
the file pointer around can result in "holes" or overwriting of
existing data in a file being written. It is an output file containing
"holes" that the term <span style="font-style: italic;">sparse writes</span>
refers to. When such a sparsely written file is read the each "hole" is
interpreted as a sequence of zero bytes. In the case of a regular file,
one
way of detecting its "sparseness" is to compare the output of the <span
 style="font-weight: bold;">du</span> and <span
 style="font-weight: bold;">ls -l</span> unix commands.<br>
<br>
The concept of sparse writes also is useful for block devices accessed
via standard Unix commands. It is also useful for direct access devices
accessed via a SCSI command set (such as SBC for disks or MMC for
cd/dvds). The underlying assumption here is that the device already has
zero bytes in the blocks that are not explicitly written to. A SCSI
disk just after the FORMAT command has been successfully performed
contains zeros in all its blocks. Another way to "zero" a SCSI disk is
with a WRITE SAME command (the ATA8 SCT feature set also contains a
WRITE SAME command).<br>
<br>
Sparse writes cannot be used when a stream (e.g. <span
 style="font-family: monospace;">stdout</span> or <span
 style="font-family: monospace;">stderr)</span> is
used as an output file.<br>
<br>
The <span style="font-family: monospace;">ddpt</span> utility
supports the '<span style="font-family: monospace;">oflag=sparse</span>'
flag. When given, <span style="font-family: monospace;">ddpt</span>
will check each buffer fetched from <span style="font-style: italic;">IFILE</span>
for zeros. The size of each buffer, perhaps apart from the last buffer,
is
<span style="font-style: italic;">BS</span>*<span
 style="font-style: italic;">BPT</span> bytes. If the buffer is full of
zeros and if the buffer is not the last one, then a sparse write is
performed. The reason for writing the last buffer, irrespective of
whether it is full of zeros or not, is so that a regular file will have
the correct length. [Any errors detected when a buffer is fetched from <span
 style="font-style: italic;">IFILE</span> will also result in zeros
being written to the <span style="font-style: italic;">OFILE</span>.]<br>
<br>
A sparse file may also be created by <span
 style="font-family: monospace;">ddpt</span> by using the '<span
 style="font-family: monospace;">seek=</span><span
 style="font-style: italic; font-family: monospace;">SEEK</span>'
option.&nbsp; Here
is an example:<br>
<br>
<span style="font-family: monospace;">$ ddpt if=/dev/zero of=t
oflag=sparse seek=1m
bs=1024 count=1</span><br style="font-family: monospace;">
<span style="font-family: monospace;">1+0 records in</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">1+0 records out</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">$ ls -lh t</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">-rw-rw-r-- 1 fred&nbsp;
fred&nbsp; 1.1G 2007-06-28 22:15 t</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">$ du -h t</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">12K&nbsp;&nbsp;&nbsp;&nbsp; t</span><br>
<br>
So the above shows that even though the file system knows the sparse
file is (logically) 1.1 GB long, it only consumes 12 KB of space within
the files
system. In the above case, <span style="font-family: monospace;">ddpt</span>
is producing the same result as the standard
<span style="font-weight: bold;">dd</span> command. Programs that
calculate checksums such as <span style="font-weight: bold;">md5sum</span>
and <span style="font-weight: bold;">sha1sum</span> should give the
same result when applied to either a sparse file or the corresponding
non-sparse file.<br>
<br>
Writing sparing is a related mechanism in which, after reading the <span
 style="font-style: italic;">IFILE</span>, the corresponding segment in
the <span style="font-style: italic;">OFILE</span> is read into
another buffer and the two buffers are compared. If unequal, the write
of the
original buffer to<span style="font-style: italic;"> OFILE</span> takes
place as normal. If equal then the write to<span
 style="font-style: italic;"> OFILE</span> is skipped. This may be
useful when a write operation is more "expensive" than a read operation
(e.g. with flash memory). The <span style="font-style: italic;">OFILE</span>
should exist and be readable and seekable (hence stdout is no
appropriate).<br>
<br>
It seems unlikely that it would be useful to have both sparse writes
and write sparing
active on the same OFILE. If they are both given (i.e. '<span
 style="font-family: monospace;">oflag=sparing,sparse</span>') then
sparse writes are checked first and if zeros are found, the check for
write sparing is skipped on that segment.<br>
<br>
<h2><a class="mozTocH2" name="mozTocId899152"></a>Verbose</h2>
In the Unix style, ddpt doesn't output anything (to stderr) during
large IO transfers. To get a progress report the SIGUSR1 signal can be
sent to the ddpt process. In the Unix dd command style, ddpt outputs
two lines on completion that show the number of full and partial
records
in (on the first line) and out (on the second line).<br>
<br>
ddpt has a 'verbose' option whose default value is zero. When set
to these values 'verbose' has the following actions:<br>
<ol>
  <li>show categorization and INQUIRY data (where applicable) for the
input and output files. For files, other than streams, the file/device
size (and device block size) are output.<br>
  </li>
  <li>same output as 1 plus data for Unix and SCSI commands (cdbs) that
are not repeated (i.e. other than Unix read/write and SCSI READ/WRITE
commands). Increased error reporting for all SCSI commands</li>
  <li>same output as 2 plus data for Unix and SCSI commands (cdbs) that
are repeated. For a large copy this will be a lot of output.</li>
  <li>maximum amount of debug output. For a large copy this will be a
lot of output.</li>
</ol>
All verbose output is sent to stderr (so that ddpt&nbsp; with "of=-"
(copy output to stdout) is not corrupted).<br>
<br>
Following is an example of using verbose=1 to find information about
<span style="font-family: monospace;">/dev/sda</span> . If no copy is
required then setting count=0 will see to
that. Since <span style="font-family: monospace;">/dev/sda</span> is a
block device then it would normally be
accessed via Unix system commands. The verbose=1 output is relatively
short to non pt devices. The second invocation is
with "iflag=pt" and more is output. That includes INQUIRY
standard response data (e.g. "SEAGATE ..." line).
See the SBC-2 drafts at <a href="http://www.t10.org/">www.t10.org</a>
for more information.<br>
<br>
<span style="font-family: monospace;">$ ddpt if=/dev/sda of=. bs=512
verbose=1 count=0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&gt;&gt; Input file type:
block device</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
open input, flags=0x0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&gt;&gt; Output file type:
null device</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
[bgs64] number of blocks=17781521 [0x10f5311], block size=512</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">0+0 records in</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">0+0 records out</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;"><br>
<br>
$ ddpt if=/dev/sda iflag=pt of=. bs=512 verbose=1 count=0</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&gt;&gt; Input file type:
block device</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
open input(pt), flags=0x2</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; /dev/sda:
SEAGATE&nbsp;&nbsp;
ST39173LC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1234&nbsp;
[pdt=0]</span><span style="font-family: monospace;"></span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&gt;&gt; Output file type:
null device</span><br style="font-family: monospace;">
&nbsp;<span style="font-family: monospace;">number of input
blocks=17781521 [0x10f5311], block size=512</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">0+0 records in</span><br
 style="font-family: monospace;">
<span style="font-family: monospace;">0+0 records out</span><br>
<br>
<br>
Mode page settings can be examined and changed with a utility like <a
 href="sdparm.html">sdparm</a> .<br>
<br>
<h2><a class="mozTocH2" name="mozTocId415792"></a>Examples</h2>
Some examples are shown in the ddpt man page.<br>
<br>
<br>
<br>
<p>Return to <a href="index.html">main</a> page. </p>
<center>
<p>Last updated: 3rd February 2009<br>
<br>
</p>
</center>
</body>
</html>
